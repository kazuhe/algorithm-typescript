# 探索

## [線形探索（liner search）](linerSearch.ts)

目的とするキー値を持つ要素に出会うまで先頭から順に走査する。
逐次探索（sequential search）とも呼ばれる。

◆ 線形探索における終了条件 ◆
1. 探索すべき値と等しい要素を見つけた => 探索成功
2. 探索すべき値が見つからず終端を通り越した（通り越しそうになった）=> 探索失敗

### [番兵法（sentinel method）](linerSearchSentinel.ts)

配列の末尾に探索すべき値を格納し、上記終了条件「1」の判定を不要とする。
番兵は繰り返しの終了判定を削減する。

## [2 分探索(binary search)](binarySearch.ts)

要素がキーの昇順か降順にソートされている配列から効率よく探索を行う。
配列の中央要素で 2 分割しながら目的のキーと出会うまで探索する。

◆ 2 分探索における終了条件 ◆
1. 探索すべき値と中央要素が一致した => 探索成功
2. 探索範囲がなくなった => 探索失敗

## [ハッシュ法(hashing)](chainHash.ts)

データを格納すべき位置（インデックス）を単純な演算で求めることで、探索だけでなく挿入や削除も効率よく行う。

例えば配列の要素数が 13 ある時、各キーを 13 で割った剰余をハッシュ値とし、それをインデックスとして用いる（ハッシュ値をインデックスとした配列をハッシュ表と呼ぶ）。

ただし、キー値とハッシュ値の対応関係は多対 1 となるため、格納すべきバケット（ハッシュ表の各要素）が衝突する可能性がある。同一ハッシュ値をもつデータを線形リストでつなぐチェイン法で衝突を解決する。

衝突がない場合は、剰余を求める O(1) の計算量で探索や挿入が可能となる。

衝突が発生した際に再ハッシュを行うことで衝突を解決するオープンアドレス法もある。

## ユースケース

| ユースケース | アルゴリズム |
| --- | --- |
| ランダムな並びの配列から任意の key を探索したい | 線形探索 |
| 昇順か降順にソートされている配列から任意の key を探索したい | 2 分探索 |
| 特定のハッシュ関数を利用して key を探索したい（既に何らかの構造にデータが格納されてい場合は向いていない） | ハッシュ法 |
